/** Generated by itemis CREATE code generator. */


#include "../Inc/sc_types.h"

#include "../Inc/buttons.h"
#include "../Inc/buttons_required.h"

/*! \file
Implementation of the state machine 'buttons'
*/

#ifndef SC_UNUSED
#define SC_UNUSED(P) (void)(P)
#endif

/* prototypes of all internal functions */

/*! State machine reactions. */
static sc_integer react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state released. */
static sc_integer right_released_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state debounce press. */
static sc_integer right_debounce_press_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state pressed. */
static sc_integer right_pressed_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state debounce release. */
static sc_integer right_debounce_release_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state Idle. */
static sc_integer gesture_right_Idle_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state Press. */
static sc_integer gesture_right_Press_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state Select. */
static sc_integer gesture_right_Select_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state released. */
static sc_integer left_released_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state debounce press. */
static sc_integer left_debounce_press_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state pressed. */
static sc_integer left_pressed_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state debounce release. */
static sc_integer left_debounce_release_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state Idle. */
static sc_integer gesture_left_Idle_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state Press. */
static sc_integer gesture_left_Press_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state Select. */
static sc_integer gesture_left_Select_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state released. */
static sc_integer hazard_released_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state debounce press. */
static sc_integer hazard_debounce_press_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state pressed. */
static sc_integer hazard_pressed_react(Buttons* handle, const sc_integer transitioned_before);

/*! The reactions of state debounce release. */
static sc_integer hazard_debounce_release_react(Buttons* handle, const sc_integer transitioned_before);


static void swap_in_events(Buttons* handle);

static void clear_in_events(Buttons* handle);

static void swap_internal_events(Buttons* handle);

static void clear_internal_events(Buttons* handle);

static void micro_step(Buttons* handle);








void buttons_init(Buttons* handle)
{
	sc_integer i;
	
	for (i = 0; i < BUTTONS_MAX_ORTHOGONAL_STATES; ++i)
	{
		handle->stateConfVector[i] = Buttons_last_state;
	}
	
				
	clear_in_events(handle);
	clear_internal_events(handle);
	swap_in_events(handle);
	swap_internal_events(handle);
	
	
	/* Default init sequence for statechart buttons */
	buttons_set_t_debounce(handle, 30);
	buttons_set_t_select(handle, 150);
	
	handle->isExecuting = bool_false;
}

void buttons_run_cycle(Buttons* handle)
{
	/* Performs a 'run to completion' step. */
	if (handle->isExecuting == bool_true)
	{ 
		return;
	} 
	handle->isExecuting = bool_true;
	swap_in_events(handle);
	do
	{ 
		micro_step(handle);
		swap_internal_events(handle);
	} while ((((handle->current.internal.pressedRight_raised == bool_true) || (handle->current.internal.releasedRight_raised == bool_true)) || (handle->current.internal.pressedLeft_raised == bool_true)) || (handle->current.internal.releasedLeft_raised == bool_true));
	handle->isExecuting = bool_false;
}

void buttons_enter(Buttons* handle)
{
	/* Activates the state machine. */
	if (handle->isExecuting == bool_true)
	{ 
		return;
	} 
	handle->isExecuting = bool_true;
	/* Default enter sequence for statechart buttons */
	/* 'default' enter sequence for region right */
	/* Default react sequence for initial entry  */
	/* 'default' enter sequence for state released */
	handle->stateConfVector[0] = Buttons_right_released;
	handle->stateConfVectorPosition = 0;
	/* 'default' enter sequence for region gesture right */
	/* Default react sequence for initial entry  */
	/* 'default' enter sequence for state Idle */
	handle->stateConfVector[1] = Buttons_gesture_right_Idle;
	handle->stateConfVectorPosition = 1;
	/* 'default' enter sequence for region left */
	/* Default react sequence for initial entry  */
	/* 'default' enter sequence for state released */
	handle->stateConfVector[2] = Buttons_left_released;
	handle->stateConfVectorPosition = 2;
	/* 'default' enter sequence for region gesture left */
	/* Default react sequence for initial entry  */
	/* 'default' enter sequence for state Idle */
	handle->stateConfVector[3] = Buttons_gesture_left_Idle;
	handle->stateConfVectorPosition = 3;
	/* 'default' enter sequence for region hazard */
	/* Default react sequence for initial entry  */
	/* 'default' enter sequence for state released */
	handle->stateConfVector[4] = Buttons_hazard_released;
	handle->stateConfVectorPosition = 4;
	handle->isExecuting = bool_false;
}

void buttons_exit(Buttons* handle)
{
	/* Deactivates the state machine. */
	if (handle->isExecuting == bool_true)
	{ 
		return;
	} 
	handle->isExecuting = bool_true;
	/* Default exit sequence for statechart buttons */
	/* Default exit sequence for region right */
	/* Handle exit of all possible states (of buttons.right) at position 0... */
	switch(handle->stateConfVector[ 0 ])
	{
		case Buttons_right_released :
		{
			/* Default exit sequence for state released */
			handle->stateConfVector[0] = Buttons_last_state;
			handle->stateConfVectorPosition = 0;
			break;
		}
		case Buttons_right_debounce_press :
		{
			/* Default exit sequence for state debounce press */
			handle->stateConfVector[0] = Buttons_last_state;
			handle->stateConfVectorPosition = 0;
			/* Exit action for state 'debounce press'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_right_debounce_press_tev0_raised) );		
			break;
		}
		case Buttons_right_pressed :
		{
			/* Default exit sequence for state pressed */
			handle->stateConfVector[0] = Buttons_last_state;
			handle->stateConfVectorPosition = 0;
			break;
		}
		case Buttons_right_debounce_release :
		{
			/* Default exit sequence for state debounce release */
			handle->stateConfVector[0] = Buttons_last_state;
			handle->stateConfVectorPosition = 0;
			/* Exit action for state 'debounce release'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_right_debounce_release_tev0_raised) );		
			break;
		}
		default: 
			/* do nothing */
			break;
	}
	/* Default exit sequence for region gesture right */
	/* Handle exit of all possible states (of buttons.gesture_right) at position 1... */
	switch(handle->stateConfVector[ 1 ])
	{
		case Buttons_gesture_right_Idle :
		{
			/* Default exit sequence for state Idle */
			handle->stateConfVector[1] = Buttons_last_state;
			handle->stateConfVectorPosition = 1;
			break;
		}
		case Buttons_gesture_right_Press :
		{
			/* Default exit sequence for state Press */
			handle->stateConfVector[1] = Buttons_last_state;
			handle->stateConfVectorPosition = 1;
			/* Exit action for state 'Press'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_gesture_right_Press_tev0_raised) );		
			break;
		}
		case Buttons_gesture_right_Select :
		{
			/* Default exit sequence for state Select */
			handle->stateConfVector[1] = Buttons_last_state;
			handle->stateConfVectorPosition = 1;
			break;
		}
		default: 
			/* do nothing */
			break;
	}
	/* Default exit sequence for region left */
	/* Handle exit of all possible states (of buttons.left) at position 2... */
	switch(handle->stateConfVector[ 2 ])
	{
		case Buttons_left_released :
		{
			/* Default exit sequence for state released */
			handle->stateConfVector[2] = Buttons_last_state;
			handle->stateConfVectorPosition = 2;
			break;
		}
		case Buttons_left_debounce_press :
		{
			/* Default exit sequence for state debounce press */
			handle->stateConfVector[2] = Buttons_last_state;
			handle->stateConfVectorPosition = 2;
			/* Exit action for state 'debounce press'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_left_debounce_press_tev0_raised) );		
			break;
		}
		case Buttons_left_pressed :
		{
			/* Default exit sequence for state pressed */
			handle->stateConfVector[2] = Buttons_last_state;
			handle->stateConfVectorPosition = 2;
			break;
		}
		case Buttons_left_debounce_release :
		{
			/* Default exit sequence for state debounce release */
			handle->stateConfVector[2] = Buttons_last_state;
			handle->stateConfVectorPosition = 2;
			/* Exit action for state 'debounce release'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_left_debounce_release_tev0_raised) );		
			break;
		}
		default: 
			/* do nothing */
			break;
	}
	/* Default exit sequence for region gesture left */
	/* Handle exit of all possible states (of buttons.gesture_left) at position 3... */
	switch(handle->stateConfVector[ 3 ])
	{
		case Buttons_gesture_left_Idle :
		{
			/* Default exit sequence for state Idle */
			handle->stateConfVector[3] = Buttons_last_state;
			handle->stateConfVectorPosition = 3;
			break;
		}
		case Buttons_gesture_left_Press :
		{
			/* Default exit sequence for state Press */
			handle->stateConfVector[3] = Buttons_last_state;
			handle->stateConfVectorPosition = 3;
			/* Exit action for state 'Press'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_gesture_left_Press_tev0_raised) );		
			break;
		}
		case Buttons_gesture_left_Select :
		{
			/* Default exit sequence for state Select */
			handle->stateConfVector[3] = Buttons_last_state;
			handle->stateConfVectorPosition = 3;
			break;
		}
		default: 
			/* do nothing */
			break;
	}
	/* Default exit sequence for region hazard */
	/* Handle exit of all possible states (of buttons.hazard) at position 4... */
	switch(handle->stateConfVector[ 4 ])
	{
		case Buttons_hazard_released :
		{
			/* Default exit sequence for state released */
			handle->stateConfVector[4] = Buttons_last_state;
			handle->stateConfVectorPosition = 4;
			break;
		}
		case Buttons_hazard_debounce_press :
		{
			/* Default exit sequence for state debounce press */
			handle->stateConfVector[4] = Buttons_last_state;
			handle->stateConfVectorPosition = 4;
			/* Exit action for state 'debounce press'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_hazard_debounce_press_tev0_raised) );		
			break;
		}
		case Buttons_hazard_pressed :
		{
			/* Default exit sequence for state pressed */
			handle->stateConfVector[4] = Buttons_last_state;
			handle->stateConfVectorPosition = 4;
			break;
		}
		case Buttons_hazard_debounce_release :
		{
			/* Default exit sequence for state debounce release */
			handle->stateConfVector[4] = Buttons_last_state;
			handle->stateConfVectorPosition = 4;
			/* Exit action for state 'debounce release'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_hazard_debounce_release_tev0_raised) );		
			break;
		}
		default: 
			/* do nothing */
			break;
	}
	handle->isExecuting = bool_false;
}


sc_boolean buttons_is_active(const Buttons* handle)
{
	sc_boolean result = bool_false;
	sc_integer i;
	
	for(i = 0; i < BUTTONS_MAX_ORTHOGONAL_STATES; i++)
	{
		result = result || handle->stateConfVector[i] != Buttons_last_state;
	}
	
	return result;
}

/* 
 * Always returns 'false' since this state machine can never become final.
 */
sc_boolean buttons_is_final(const Buttons* handle)
{
	SC_UNUSED(handle);
	return bool_false;
}

void buttons_raise_time_event(Buttons* handle, sc_eventid evid)
{
	if ( ((sc_intptr_t)evid) >= ((sc_intptr_t)&(handle->timeEvents))
		&&  ((sc_intptr_t)evid) < ((sc_intptr_t)&(handle->timeEvents)) + (unsigned)sizeof(ButtonsTimeEvents))
		{
		*(sc_boolean*)evid = bool_true;
	}
}

sc_boolean buttons_is_state_active(const Buttons* handle, ButtonsStates state)
{
	sc_boolean result = bool_false;
	switch (state)
	{
		case Buttons_right_released :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_RIGHT_RELEASED] == Buttons_right_released
			);
				break;
		case Buttons_right_debounce_press :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_RIGHT_DEBOUNCE_PRESS] == Buttons_right_debounce_press
			);
				break;
		case Buttons_right_pressed :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_RIGHT_PRESSED] == Buttons_right_pressed
			);
				break;
		case Buttons_right_debounce_release :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_RIGHT_DEBOUNCE_RELEASE] == Buttons_right_debounce_release
			);
				break;
		case Buttons_gesture_right_Idle :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_GESTURE_RIGHT_IDLE] == Buttons_gesture_right_Idle
			);
				break;
		case Buttons_gesture_right_Press :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_GESTURE_RIGHT_PRESS] == Buttons_gesture_right_Press
			);
				break;
		case Buttons_gesture_right_Select :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_GESTURE_RIGHT_SELECT] == Buttons_gesture_right_Select
			);
				break;
		case Buttons_left_released :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_LEFT_RELEASED] == Buttons_left_released
			);
				break;
		case Buttons_left_debounce_press :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_LEFT_DEBOUNCE_PRESS] == Buttons_left_debounce_press
			);
				break;
		case Buttons_left_pressed :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_LEFT_PRESSED] == Buttons_left_pressed
			);
				break;
		case Buttons_left_debounce_release :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_LEFT_DEBOUNCE_RELEASE] == Buttons_left_debounce_release
			);
				break;
		case Buttons_gesture_left_Idle :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_GESTURE_LEFT_IDLE] == Buttons_gesture_left_Idle
			);
				break;
		case Buttons_gesture_left_Press :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_GESTURE_LEFT_PRESS] == Buttons_gesture_left_Press
			);
				break;
		case Buttons_gesture_left_Select :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_GESTURE_LEFT_SELECT] == Buttons_gesture_left_Select
			);
				break;
		case Buttons_hazard_released :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_HAZARD_RELEASED] == Buttons_hazard_released
			);
				break;
		case Buttons_hazard_debounce_press :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_HAZARD_DEBOUNCE_PRESS] == Buttons_hazard_debounce_press
			);
				break;
		case Buttons_hazard_pressed :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_HAZARD_PRESSED] == Buttons_hazard_pressed
			);
				break;
		case Buttons_hazard_debounce_release :
			result = (sc_boolean) (handle->stateConfVector[SCVI_BUTTONS_HAZARD_DEBOUNCE_RELEASE] == Buttons_hazard_debounce_release
			);
				break;
			default:
				result = bool_false;
				break;
		}
		return result;
	}

static void swap_in_events(Buttons* handle)
{
	handle->current.timeEvents.buttons_right_debounce_press_time_event_0_raised = handle->timeEvents.buttons_right_debounce_press_tev0_raised;
	handle->timeEvents.buttons_right_debounce_press_tev0_raised = bool_false;
	handle->current.timeEvents.buttons_right_debounce_release_time_event_0_raised = handle->timeEvents.buttons_right_debounce_release_tev0_raised;
	handle->timeEvents.buttons_right_debounce_release_tev0_raised = bool_false;
	handle->current.timeEvents.buttons_gesture_right_Press_time_event_0_raised = handle->timeEvents.buttons_gesture_right_Press_tev0_raised;
	handle->timeEvents.buttons_gesture_right_Press_tev0_raised = bool_false;
	handle->current.timeEvents.buttons_left_debounce_press_time_event_0_raised = handle->timeEvents.buttons_left_debounce_press_tev0_raised;
	handle->timeEvents.buttons_left_debounce_press_tev0_raised = bool_false;
	handle->current.timeEvents.buttons_left_debounce_release_time_event_0_raised = handle->timeEvents.buttons_left_debounce_release_tev0_raised;
	handle->timeEvents.buttons_left_debounce_release_tev0_raised = bool_false;
	handle->current.timeEvents.buttons_gesture_left_Press_time_event_0_raised = handle->timeEvents.buttons_gesture_left_Press_tev0_raised;
	handle->timeEvents.buttons_gesture_left_Press_tev0_raised = bool_false;
	handle->current.timeEvents.buttons_hazard_debounce_press_time_event_0_raised = handle->timeEvents.buttons_hazard_debounce_press_tev0_raised;
	handle->timeEvents.buttons_hazard_debounce_press_tev0_raised = bool_false;
	handle->current.timeEvents.buttons_hazard_debounce_release_time_event_0_raised = handle->timeEvents.buttons_hazard_debounce_release_tev0_raised;
	handle->timeEvents.buttons_hazard_debounce_release_tev0_raised = bool_false;
}

static void clear_in_events(Buttons* handle)
{
	handle->timeEvents.buttons_right_debounce_press_tev0_raised = bool_false;
	handle->timeEvents.buttons_right_debounce_release_tev0_raised = bool_false;
	handle->timeEvents.buttons_gesture_right_Press_tev0_raised = bool_false;
	handle->timeEvents.buttons_left_debounce_press_tev0_raised = bool_false;
	handle->timeEvents.buttons_left_debounce_release_tev0_raised = bool_false;
	handle->timeEvents.buttons_gesture_left_Press_tev0_raised = bool_false;
	handle->timeEvents.buttons_hazard_debounce_press_tev0_raised = bool_false;
	handle->timeEvents.buttons_hazard_debounce_release_tev0_raised = bool_false;
}

static void swap_internal_events(Buttons* handle)
{
	/* When processing internal events all incoming events are processed and must be cleared from current buffer. */
	handle->current.timeEvents.buttons_right_debounce_press_time_event_0_raised = bool_false;
	handle->current.timeEvents.buttons_right_debounce_release_time_event_0_raised = bool_false;
	handle->current.timeEvents.buttons_gesture_right_Press_time_event_0_raised = bool_false;
	handle->current.timeEvents.buttons_left_debounce_press_time_event_0_raised = bool_false;
	handle->current.timeEvents.buttons_left_debounce_release_time_event_0_raised = bool_false;
	handle->current.timeEvents.buttons_gesture_left_Press_time_event_0_raised = bool_false;
	handle->current.timeEvents.buttons_hazard_debounce_press_time_event_0_raised = bool_false;
	handle->current.timeEvents.buttons_hazard_debounce_release_time_event_0_raised = bool_false;
	/* Swap all internal events. */
	handle->current.internal.pressedRight_raised = handle->internal.pressedRight_raised;
	handle->internal.pressedRight_raised = bool_false;
	handle->current.internal.releasedRight_raised = handle->internal.releasedRight_raised;
	handle->internal.releasedRight_raised = bool_false;
	handle->current.internal.pressedLeft_raised = handle->internal.pressedLeft_raised;
	handle->internal.pressedLeft_raised = bool_false;
	handle->current.internal.releasedLeft_raised = handle->internal.releasedLeft_raised;
	handle->internal.releasedLeft_raised = bool_false;
}

static void clear_internal_events(Buttons* handle)
{
	handle->internal.pressedRight_raised = bool_false;
	handle->internal.releasedRight_raised = bool_false;
	handle->internal.pressedLeft_raised = bool_false;
	handle->internal.releasedLeft_raised = bool_false;
}

static void micro_step(Buttons* handle)
{
 			sc_integer transitioned = -1;
	handle->stateConfVectorPosition = 0;
	switch(handle->stateConfVector[ 0 ])
	{
		case Buttons_right_released :
		{
			transitioned = right_released_react(handle,transitioned);
			break;
		}
		case Buttons_right_debounce_press :
		{
			transitioned = right_debounce_press_react(handle,transitioned);
			break;
		}
		case Buttons_right_pressed :
		{
			transitioned = right_pressed_react(handle,transitioned);
			break;
		}
		case Buttons_right_debounce_release :
		{
			transitioned = right_debounce_release_react(handle,transitioned);
			break;
		}
		default: 
			/* do nothing */
			break;
	}
	if ((handle->stateConfVectorPosition) < (1))
	{ 
		switch(handle->stateConfVector[ 1 ])
		{
			case Buttons_gesture_right_Idle :
			{
				transitioned = gesture_right_Idle_react(handle,transitioned);
				break;
			}
			case Buttons_gesture_right_Press :
			{
				transitioned = gesture_right_Press_react(handle,transitioned);
				break;
			}
			case Buttons_gesture_right_Select :
			{
				transitioned = gesture_right_Select_react(handle,transitioned);
				break;
			}
			default: 
				/* do nothing */
				break;
		}
	} if ((handle->stateConfVectorPosition) < (2))
	{ 
		switch(handle->stateConfVector[ 2 ])
		{
			case Buttons_left_released :
			{
				transitioned = left_released_react(handle,transitioned);
				break;
			}
			case Buttons_left_debounce_press :
			{
				transitioned = left_debounce_press_react(handle,transitioned);
				break;
			}
			case Buttons_left_pressed :
			{
				transitioned = left_pressed_react(handle,transitioned);
				break;
			}
			case Buttons_left_debounce_release :
			{
				transitioned = left_debounce_release_react(handle,transitioned);
				break;
			}
			default: 
				/* do nothing */
				break;
		}
	} if ((handle->stateConfVectorPosition) < (3))
	{ 
		switch(handle->stateConfVector[ 3 ])
		{
			case Buttons_gesture_left_Idle :
			{
				transitioned = gesture_left_Idle_react(handle,transitioned);
				break;
			}
			case Buttons_gesture_left_Press :
			{
				transitioned = gesture_left_Press_react(handle,transitioned);
				break;
			}
			case Buttons_gesture_left_Select :
			{
				transitioned = gesture_left_Select_react(handle,transitioned);
				break;
			}
			default: 
				/* do nothing */
				break;
		}
	} if ((handle->stateConfVectorPosition) < (4))
	{ 
		switch(handle->stateConfVector[ 4 ])
		{
			case Buttons_hazard_released :
			{
				hazard_released_react(handle,transitioned);
				break;
			}
			case Buttons_hazard_debounce_press :
			{
				hazard_debounce_press_react(handle,transitioned);
				break;
			}
			case Buttons_hazard_pressed :
			{
				hazard_pressed_react(handle,transitioned);
				break;
			}
			case Buttons_hazard_debounce_release :
			{
				hazard_debounce_release_react(handle,transitioned);
				break;
			}
			default: 
				/* do nothing */
				break;
		}
	} 
}




sc_integer buttons_get_t_debounce(const Buttons* handle)
{
	return handle->iface.t_debounce;
}
void buttons_set_t_debounce(Buttons* handle, sc_integer value)
{
	handle->iface.t_debounce = value;
}
sc_integer buttons_get_t_select(const Buttons* handle)
{
	return handle->iface.t_select;
}
void buttons_set_t_select(Buttons* handle, sc_integer value)
{
	handle->iface.t_select = value;
}



/* implementations of all internal functions */


static sc_integer react(Buttons* handle, const sc_integer transitioned_before)
{
	/* State machine reactions. */
	if (handle->current.internal.pressedRight_raised == bool_true)
	{ 
		buttons_pressed(handle,1);
	} 
	if (handle->current.internal.releasedRight_raised == bool_true)
	{ 
		buttons_released(handle,1);
	} 
	return transitioned_before;
}

static sc_integer right_released_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state released. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if ((HAL_GPIO_ReadPin(BUTTON_RIGHT_GPIO_Port, BUTTON_RIGHT_Pin)) == (GPIO_PIN_RESET))
		{ 
			/* Default exit sequence for state released */
			handle->stateConfVector[0] = Buttons_last_state;
			handle->stateConfVectorPosition = 0;
			/* 'default' enter sequence for state debounce press */
			/* Entry action for state 'debounce press'. */
			buttons_set_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_right_debounce_press_tev0_raised) , handle->iface.t_debounce, bool_false);
			handle->stateConfVector[0] = Buttons_right_debounce_press;
			handle->stateConfVectorPosition = 0;
			transitioned_after = 0;
		} 
	} 
	return transitioned_after;
}

static sc_integer right_debounce_press_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state debounce press. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->current.timeEvents.buttons_right_debounce_press_time_event_0_raised == bool_true)
		{ 
			/* Default exit sequence for state debounce press */
			handle->stateConfVector[0] = Buttons_last_state;
			handle->stateConfVectorPosition = 0;
			/* Exit action for state 'debounce press'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_right_debounce_press_tev0_raised) );		
			handle->current.timeEvents.buttons_right_debounce_press_time_event_0_raised = bool_false;
			/* The reactions of state null. */
			if ((HAL_GPIO_ReadPin(BUTTON_RIGHT_GPIO_Port, BUTTON_RIGHT_Pin)) == (GPIO_PIN_SET))
			{ 
				/* 'default' enter sequence for state released */
				handle->stateConfVector[0] = Buttons_right_released;
				handle->stateConfVectorPosition = 0;
			}  else
			{
				handle->internal.pressedRight_raised = bool_true;
				/* 'default' enter sequence for state pressed */
				handle->stateConfVector[0] = Buttons_right_pressed;
				handle->stateConfVectorPosition = 0;
			}
			transitioned_after = 0;
		} 
	} 
	return transitioned_after;
}

static sc_integer right_pressed_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state pressed. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if ((HAL_GPIO_ReadPin(BUTTON_RIGHT_GPIO_Port, BUTTON_RIGHT_Pin)) == (GPIO_PIN_SET))
		{ 
			/* Default exit sequence for state pressed */
			handle->stateConfVector[0] = Buttons_last_state;
			handle->stateConfVectorPosition = 0;
			/* 'default' enter sequence for state debounce release */
			/* Entry action for state 'debounce release'. */
			buttons_set_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_right_debounce_release_tev0_raised) , handle->iface.t_debounce, bool_false);
			handle->stateConfVector[0] = Buttons_right_debounce_release;
			handle->stateConfVectorPosition = 0;
			transitioned_after = 0;
		} 
	} 
	return transitioned_after;
}

static sc_integer right_debounce_release_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state debounce release. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->current.timeEvents.buttons_right_debounce_release_time_event_0_raised == bool_true)
		{ 
			/* Default exit sequence for state debounce release */
			handle->stateConfVector[0] = Buttons_last_state;
			handle->stateConfVectorPosition = 0;
			/* Exit action for state 'debounce release'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_right_debounce_release_tev0_raised) );		
			handle->current.timeEvents.buttons_right_debounce_release_time_event_0_raised = bool_false;
			/* The reactions of state null. */
			if ((HAL_GPIO_ReadPin(BUTTON_RIGHT_GPIO_Port, BUTTON_RIGHT_Pin)) == (GPIO_PIN_RESET))
			{ 
				/* 'default' enter sequence for state pressed */
				handle->stateConfVector[0] = Buttons_right_pressed;
				handle->stateConfVectorPosition = 0;
			}  else
			{
				handle->internal.releasedRight_raised = bool_true;
				/* 'default' enter sequence for state released */
				handle->stateConfVector[0] = Buttons_right_released;
				handle->stateConfVectorPosition = 0;
			}
			transitioned_after = 0;
		} 
	} 
	return transitioned_after;
}

static sc_integer gesture_right_Idle_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Idle. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (1))
	{ 
		if (handle->current.internal.pressedRight_raised == bool_true)
		{ 
			/* Default exit sequence for state Idle */
			handle->stateConfVector[1] = Buttons_last_state;
			handle->stateConfVectorPosition = 1;
			/* 'default' enter sequence for state Press */
			/* Entry action for state 'Press'. */
			buttons_set_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_gesture_right_Press_tev0_raised) , handle->iface.t_select, bool_false);
			handle->stateConfVector[1] = Buttons_gesture_right_Press;
			handle->stateConfVectorPosition = 1;
			transitioned_after = 1;
		} 
	} 
	return transitioned_after;
}

static sc_integer gesture_right_Press_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Press. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (1))
	{ 
		if (handle->current.internal.releasedRight_raised == bool_true)
		{ 
			/* Default exit sequence for state Press */
			handle->stateConfVector[1] = Buttons_last_state;
			handle->stateConfVectorPosition = 1;
			/* Exit action for state 'Press'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_gesture_right_Press_tev0_raised) );		
			buttons_tipped(handle,1);
			/* 'default' enter sequence for state Idle */
			handle->stateConfVector[1] = Buttons_gesture_right_Idle;
			handle->stateConfVectorPosition = 1;
			transitioned_after = 1;
		}  else
		{
			if (handle->current.timeEvents.buttons_gesture_right_Press_time_event_0_raised == bool_true)
			{ 
				/* Default exit sequence for state Press */
				handle->stateConfVector[1] = Buttons_last_state;
				handle->stateConfVectorPosition = 1;
				/* Exit action for state 'Press'. */
				buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_gesture_right_Press_tev0_raised) );		
				handle->current.timeEvents.buttons_gesture_right_Press_time_event_0_raised = bool_false;
				/* 'default' enter sequence for state Select */
				handle->stateConfVector[1] = Buttons_gesture_right_Select;
				handle->stateConfVectorPosition = 1;
				transitioned_after = 1;
			} 
		}
	} 
	return transitioned_after;
}

static sc_integer gesture_right_Select_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Select. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (1))
	{ 
		if (handle->current.internal.releasedRight_raised == bool_true)
		{ 
			/* Default exit sequence for state Select */
			handle->stateConfVector[1] = Buttons_last_state;
			handle->stateConfVectorPosition = 1;
			buttons_selected(handle,1);
			/* 'default' enter sequence for state Idle */
			handle->stateConfVector[1] = Buttons_gesture_right_Idle;
			handle->stateConfVectorPosition = 1;
			transitioned_after = 1;
		} 
	} 
	return transitioned_after;
}

static sc_integer left_released_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state released. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (2))
	{ 
		if ((HAL_GPIO_ReadPin(BUTTON_LEFT_GPIO_Port, BUTTON_LEFT_Pin)) == (GPIO_PIN_RESET))
		{ 
			/* Default exit sequence for state released */
			handle->stateConfVector[2] = Buttons_last_state;
			handle->stateConfVectorPosition = 2;
			/* 'default' enter sequence for state debounce press */
			/* Entry action for state 'debounce press'. */
			buttons_set_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_left_debounce_press_tev0_raised) , handle->iface.t_debounce, bool_false);
			handle->stateConfVector[2] = Buttons_left_debounce_press;
			handle->stateConfVectorPosition = 2;
			transitioned_after = 2;
		} 
	} 
	return transitioned_after;
}

static sc_integer left_debounce_press_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state debounce press. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (2))
	{ 
		if (handle->current.timeEvents.buttons_left_debounce_press_time_event_0_raised == bool_true)
		{ 
			/* Default exit sequence for state debounce press */
			handle->stateConfVector[2] = Buttons_last_state;
			handle->stateConfVectorPosition = 2;
			/* Exit action for state 'debounce press'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_left_debounce_press_tev0_raised) );		
			handle->current.timeEvents.buttons_left_debounce_press_time_event_0_raised = bool_false;
			/* The reactions of state null. */
			if ((HAL_GPIO_ReadPin(BUTTON_LEFT_GPIO_Port, BUTTON_LEFT_Pin)) == (GPIO_PIN_SET))
			{ 
				/* 'default' enter sequence for state released */
				handle->stateConfVector[2] = Buttons_left_released;
				handle->stateConfVectorPosition = 2;
			}  else
			{
				handle->internal.pressedLeft_raised = bool_true;
				/* 'default' enter sequence for state pressed */
				handle->stateConfVector[2] = Buttons_left_pressed;
				handle->stateConfVectorPosition = 2;
			}
			transitioned_after = 2;
		} 
	} 
	return transitioned_after;
}

static sc_integer left_pressed_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state pressed. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (2))
	{ 
		if ((HAL_GPIO_ReadPin(BUTTON_LEFT_GPIO_Port, BUTTON_LEFT_Pin)) == (GPIO_PIN_SET))
		{ 
			/* Default exit sequence for state pressed */
			handle->stateConfVector[2] = Buttons_last_state;
			handle->stateConfVectorPosition = 2;
			/* 'default' enter sequence for state debounce release */
			/* Entry action for state 'debounce release'. */
			buttons_set_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_left_debounce_release_tev0_raised) , handle->iface.t_debounce, bool_false);
			handle->stateConfVector[2] = Buttons_left_debounce_release;
			handle->stateConfVectorPosition = 2;
			transitioned_after = 2;
		} 
	} 
	return transitioned_after;
}

static sc_integer left_debounce_release_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state debounce release. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (2))
	{ 
		if (handle->current.timeEvents.buttons_left_debounce_release_time_event_0_raised == bool_true)
		{ 
			/* Default exit sequence for state debounce release */
			handle->stateConfVector[2] = Buttons_last_state;
			handle->stateConfVectorPosition = 2;
			/* Exit action for state 'debounce release'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_left_debounce_release_tev0_raised) );		
			handle->current.timeEvents.buttons_left_debounce_release_time_event_0_raised = bool_false;
			/* The reactions of state null. */
			if ((HAL_GPIO_ReadPin(BUTTON_LEFT_GPIO_Port, BUTTON_LEFT_Pin)) == (GPIO_PIN_RESET))
			{ 
				/* 'default' enter sequence for state pressed */
				handle->stateConfVector[2] = Buttons_left_pressed;
				handle->stateConfVectorPosition = 2;
			}  else
			{
				handle->internal.releasedLeft_raised = bool_true;
				/* 'default' enter sequence for state released */
				handle->stateConfVector[2] = Buttons_left_released;
				handle->stateConfVectorPosition = 2;
			}
			transitioned_after = 2;
		} 
	} 
	return transitioned_after;
}

static sc_integer gesture_left_Idle_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Idle. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (3))
	{ 
		if (handle->current.internal.pressedLeft_raised == bool_true)
		{ 
			/* Default exit sequence for state Idle */
			handle->stateConfVector[3] = Buttons_last_state;
			handle->stateConfVectorPosition = 3;
			/* 'default' enter sequence for state Press */
			/* Entry action for state 'Press'. */
			buttons_set_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_gesture_left_Press_tev0_raised) , handle->iface.t_select, bool_false);
			handle->stateConfVector[3] = Buttons_gesture_left_Press;
			handle->stateConfVectorPosition = 3;
			transitioned_after = 3;
		} 
	} 
	return transitioned_after;
}

static sc_integer gesture_left_Press_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Press. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (3))
	{ 
		if (handle->current.internal.releasedLeft_raised == bool_true)
		{ 
			/* Default exit sequence for state Press */
			handle->stateConfVector[3] = Buttons_last_state;
			handle->stateConfVectorPosition = 3;
			/* Exit action for state 'Press'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_gesture_left_Press_tev0_raised) );		
			buttons_tipped(handle,2);
			/* 'default' enter sequence for state Idle */
			handle->stateConfVector[3] = Buttons_gesture_left_Idle;
			handle->stateConfVectorPosition = 3;
			transitioned_after = 3;
		}  else
		{
			if (handle->current.timeEvents.buttons_gesture_left_Press_time_event_0_raised == bool_true)
			{ 
				/* Default exit sequence for state Press */
				handle->stateConfVector[3] = Buttons_last_state;
				handle->stateConfVectorPosition = 3;
				/* Exit action for state 'Press'. */
				buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_gesture_left_Press_tev0_raised) );		
				handle->current.timeEvents.buttons_gesture_left_Press_time_event_0_raised = bool_false;
				/* 'default' enter sequence for state Select */
				handle->stateConfVector[3] = Buttons_gesture_left_Select;
				handle->stateConfVectorPosition = 3;
				transitioned_after = 3;
			} 
		}
	} 
	return transitioned_after;
}

static sc_integer gesture_left_Select_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Select. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (3))
	{ 
		if (handle->current.internal.releasedLeft_raised == bool_true)
		{ 
			/* Default exit sequence for state Select */
			handle->stateConfVector[3] = Buttons_last_state;
			handle->stateConfVectorPosition = 3;
			buttons_selected(handle,2);
			/* 'default' enter sequence for state Idle */
			handle->stateConfVector[3] = Buttons_gesture_left_Idle;
			handle->stateConfVectorPosition = 3;
			transitioned_after = 3;
		} 
	} 
	return transitioned_after;
}

static sc_integer hazard_released_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state released. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (4))
	{ 
		if ((HAL_GPIO_ReadPin(BUTTON_HAZARD_GPIO_Port, BUTTON_HAZARD_Pin)) == (GPIO_PIN_RESET))
		{ 
			/* Default exit sequence for state released */
			handle->stateConfVector[4] = Buttons_last_state;
			handle->stateConfVectorPosition = 4;
			/* 'default' enter sequence for state debounce press */
			/* Entry action for state 'debounce press'. */
			buttons_set_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_hazard_debounce_press_tev0_raised) , handle->iface.t_debounce, bool_false);
			handle->stateConfVector[4] = Buttons_hazard_debounce_press;
			handle->stateConfVectorPosition = 4;
			react(handle,0);
			transitioned_after = 4;
		} 
	} 
	/* If no transition was taken */
	if ((transitioned_after) == (transitioned_before))
	{ 
		/* then execute local reactions. */
		transitioned_after = react(handle,transitioned_before);
	} 
	return transitioned_after;
}

static sc_integer hazard_debounce_press_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state debounce press. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (4))
	{ 
		if (handle->current.timeEvents.buttons_hazard_debounce_press_time_event_0_raised == bool_true)
		{ 
			/* Default exit sequence for state debounce press */
			handle->stateConfVector[4] = Buttons_last_state;
			handle->stateConfVectorPosition = 4;
			/* Exit action for state 'debounce press'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_hazard_debounce_press_tev0_raised) );		
			handle->current.timeEvents.buttons_hazard_debounce_press_time_event_0_raised = bool_false;
			/* The reactions of state null. */
			if ((HAL_GPIO_ReadPin(BUTTON_HAZARD_GPIO_Port, BUTTON_HAZARD_Pin)) == (GPIO_PIN_SET))
			{ 
				/* 'default' enter sequence for state released */
				handle->stateConfVector[4] = Buttons_hazard_released;
				handle->stateConfVectorPosition = 4;
			}  else
			{
				buttons_pressed(handle,3);
				/* 'default' enter sequence for state pressed */
				handle->stateConfVector[4] = Buttons_hazard_pressed;
				handle->stateConfVectorPosition = 4;
			}
			transitioned_after = 4;
		} 
	} 
	/* If no transition was taken */
	if ((transitioned_after) == (transitioned_before))
	{ 
		/* then execute local reactions. */
		transitioned_after = react(handle,transitioned_before);
	} 
	return transitioned_after;
}

static sc_integer hazard_pressed_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state pressed. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (4))
	{ 
		if ((HAL_GPIO_ReadPin(BUTTON_HAZARD_GPIO_Port, BUTTON_HAZARD_Pin)) == (GPIO_PIN_SET))
		{ 
			/* Default exit sequence for state pressed */
			handle->stateConfVector[4] = Buttons_last_state;
			handle->stateConfVectorPosition = 4;
			/* 'default' enter sequence for state debounce release */
			/* Entry action for state 'debounce release'. */
			buttons_set_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_hazard_debounce_release_tev0_raised) , handle->iface.t_debounce, bool_false);
			handle->stateConfVector[4] = Buttons_hazard_debounce_release;
			handle->stateConfVectorPosition = 4;
			react(handle,0);
			transitioned_after = 4;
		} 
	} 
	/* If no transition was taken */
	if ((transitioned_after) == (transitioned_before))
	{ 
		/* then execute local reactions. */
		transitioned_after = react(handle,transitioned_before);
	} 
	return transitioned_after;
}

static sc_integer hazard_debounce_release_react(Buttons* handle, const sc_integer transitioned_before)
{
	/* The reactions of state debounce release. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (4))
	{ 
		if (handle->current.timeEvents.buttons_hazard_debounce_release_time_event_0_raised == bool_true)
		{ 
			/* Default exit sequence for state debounce release */
			handle->stateConfVector[4] = Buttons_last_state;
			handle->stateConfVectorPosition = 4;
			/* Exit action for state 'debounce release'. */
			buttons_unset_timer(handle, (sc_eventid) &(handle->timeEvents.buttons_hazard_debounce_release_tev0_raised) );		
			handle->current.timeEvents.buttons_hazard_debounce_release_time_event_0_raised = bool_false;
			/* The reactions of state null. */
			if ((HAL_GPIO_ReadPin(BUTTON_HAZARD_GPIO_Port, BUTTON_HAZARD_Pin)) == (GPIO_PIN_RESET))
			{ 
				/* 'default' enter sequence for state pressed */
				handle->stateConfVector[4] = Buttons_hazard_pressed;
				handle->stateConfVectorPosition = 4;
			}  else
			{
				buttons_released(handle,3);
				/* 'default' enter sequence for state released */
				handle->stateConfVector[4] = Buttons_hazard_released;
				handle->stateConfVectorPosition = 4;
			}
			transitioned_after = 4;
		} 
	} 
	/* If no transition was taken */
	if ((transitioned_after) == (transitioned_before))
	{ 
		/* then execute local reactions. */
		transitioned_after = react(handle,transitioned_before);
	} 
	return transitioned_after;
}




