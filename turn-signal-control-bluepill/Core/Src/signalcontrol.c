/** Generated by itemis CREATE code generator. */


#include "../Inc/sc_types.h"

#include "../Inc/signalcontrol.h"

/*! \file
Implementation of the state machine 'signalcontrol'
*/

#ifndef SC_UNUSED
#define SC_UNUSED(P) (void)(P)
#endif

/* prototypes of all internal functions */
static void dhenseq_main_Blink_r(Signalcontrol* handle);
static void dhenseq_main_Blink_r_Right_right(Signalcontrol* handle);
static void dhenseq_main_Blink_r_Left_left(Signalcontrol* handle);
static void react_main_Blink_r_Right_right__choice_0(Signalcontrol* handle);

/*! State machine reactions. */
static sc_integer react(Signalcontrol* handle, const sc_integer transitioned_before);

/*! The reactions of state Idle. */
static sc_integer main_Idle_react(Signalcontrol* handle, const sc_integer transitioned_before);

/*! The reactions of state Blink. */
static sc_integer main_Blink_react(Signalcontrol* handle, const sc_integer transitioned_before);

/*! The reactions of state Right. */
static sc_integer main_Blink_r_Right_react(Signalcontrol* handle, const sc_integer transitioned_before);

/*! The reactions of state Comfort. */
static sc_integer main_Blink_r_Right_right_Comfort_react(Signalcontrol* handle, const sc_integer transitioned_before);

/*! The reactions of state Regular. */
static sc_integer main_Blink_r_Right_right_Regular_react(Signalcontrol* handle, const sc_integer transitioned_before);

/*! The reactions of state Left. */
static sc_integer main_Blink_r_Left_react(Signalcontrol* handle, const sc_integer transitioned_before);

/*! The reactions of state Comfort. */
static sc_integer main_Blink_r_Left_left_Comfort_react(Signalcontrol* handle, const sc_integer transitioned_before);

/*! The reactions of state Regular. */
static sc_integer main_Blink_r_Left_left_Regular_react(Signalcontrol* handle, const sc_integer transitioned_before);

/*! The reactions of state Hazard Lights. */
static sc_integer main_Hazard_Lights_react(Signalcontrol* handle, const sc_integer transitioned_before);


static void clear_in_events(Signalcontrol* handle);

static void clear_internal_events(Signalcontrol* handle);

static void micro_step(Signalcontrol* handle);

/*! Performs a 'run to completion' step. */
static void run_cycle(Signalcontrol* handle);


static void on_blinkRight_cycleCompleted(Signalcontrol* handle);
static void on_blinkLeft_cycleCompleted(Signalcontrol* handle);


static void signalcontrol_internal_set_interrupted(Signalcontrol* handle, sc_boolean value)
;
static void signalcontrol_internal_set_periodCount(Signalcontrol* handle, sc_integer value)
;


static void signalcontrol_eventqueue_init(signalcontrol_eventqueue * eq, signalcontrol_event *buffer, sc_integer capacity);
static sc_integer signalcontrol_eventqueue_size(signalcontrol_eventqueue * eq);
static void signalcontrol_event_init(signalcontrol_event * ev, SignalcontrolEventID name);
static signalcontrol_event signalcontrol_eventqueue_pop(signalcontrol_eventqueue * eq);
static sc_boolean signalcontrol_eventqueue_push(signalcontrol_eventqueue * eq, signalcontrol_event ev);
static void signalcontrol_add_event_to_queue(signalcontrol_eventqueue * eq, SignalcontrolEventID name);
static sc_boolean signalcontrol_dispatch_event(Signalcontrol* handle, const signalcontrol_event * event);
static signalcontrol_event signalcontrol_get_next_event(Signalcontrol* handle);
static sc_boolean signalcontrol_dispatch_next_event(Signalcontrol* handle);
static void signalcontrol_event_value_init(signalcontrol_event * ev, SignalcontrolEventID name, void * value);
static void signalcontrol_add_value_event_to_queue(signalcontrol_eventqueue * eq, SignalcontrolEventID name, void * value);


void signalcontrol_init(Signalcontrol* handle)
{
	sc_integer i;
	
	for (i = 0; i < SIGNALCONTROL_MAX_ORTHOGONAL_STATES; ++i)
	{
		handle->stateConfVector[i] = Signalcontrol_last_state;
	}
	
	for (i = 0; i < SIGNALCONTROL_MAX_HISTORY_STATES; ++i)
	{
		handle->historyVector[i] = Signalcontrol_last_state;
	}
				
	clear_in_events(handle);
	clear_internal_events(handle);
	
	sc_single_subscription_observer_init(&(handle->shadow.blinkRight_cycleCompleted), handle, (sc_observer_next_fp)on_blinkRight_cycleCompleted);
	sc_single_subscription_observer_init(&(handle->shadow.blinkLeft_cycleCompleted), handle, (sc_observer_next_fp)on_blinkLeft_cycleCompleted);
	
	handle->iface.blinkRight = sc_null;
	handle->iface.blinkLeft = sc_null;
	/* Default init sequence for statechart signalcontrol */
	signalcontrol_set_blinkRight(handle, sc_null);
	signalcontrol_set_blinkLeft(handle, sc_null);
	signalcontrol_set_flash(handle, sc_null);
	signalcontrol_set_comfortBlinkingPeriods(handle, 3);
	signalcontrol_internal_set_interrupted(handle, bool_false);
	signalcontrol_internal_set_periodCount(handle, 0);
	
	handle->isExecuting = bool_false;
	signalcontrol_eventqueue_init(&handle->internal_event_queue, handle->internal_buffer, SIGNALCONTROL_INTERNAL_EVENTQUEUE_BUFFERSIZE);
	signalcontrol_eventqueue_init(&handle->in_event_queue, handle->in_buffer, SIGNALCONTROL_IN_EVENTQUEUE_BUFFERSIZE);
}

void signalcontrol_enter(Signalcontrol* handle)
{
	/* Activates the state machine. */
	if (handle->isExecuting == bool_true)
	{ 
		return;
	} 
	handle->isExecuting = bool_true;
	/* Default enter sequence for statechart signalcontrol */
	/* 'default' enter sequence for region main */
	/* Default react sequence for initial entry  */
	/* 'default' enter sequence for state Idle */
	handle->stateConfVector[0] = Signalcontrol_main_Idle;
	handle->isExecuting = bool_false;
}

void signalcontrol_exit(Signalcontrol* handle)
{
	/* Deactivates the state machine. */
	if (handle->isExecuting == bool_true)
	{ 
		return;
	} 
	handle->isExecuting = bool_true;
	/* Default exit sequence for statechart signalcontrol */
	/* Default exit sequence for region main */
	/* Handle exit of all possible states (of signalcontrol.main) at position 0... */
	switch(handle->stateConfVector[ 0 ])
	{
		case Signalcontrol_main_Idle :
		{
			/* Default exit sequence for state Idle */
			handle->stateConfVector[0] = Signalcontrol_last_state;
			break;
		}
		case Signalcontrol_main_Blink_r_Right_right_Comfort :
		{
			/* Default exit sequence for state Comfort */
			handle->stateConfVector[0] = Signalcontrol_last_state;
			/* Exit action for state 'Right'. */
			blink_exit(handle->iface.blinkRight);
			break;
		}
		case Signalcontrol_main_Blink_r_Right_right_Regular :
		{
			/* Default exit sequence for state Regular */
			handle->stateConfVector[0] = Signalcontrol_last_state;
			/* Exit action for state 'Right'. */
			blink_exit(handle->iface.blinkRight);
			break;
		}
		case Signalcontrol_main_Blink_r_Left_left_Comfort :
		{
			/* Default exit sequence for state Comfort */
			handle->stateConfVector[0] = Signalcontrol_last_state;
			/* Exit action for state 'Left'. */
			blink_exit(handle->iface.blinkLeft);
			break;
		}
		case Signalcontrol_main_Blink_r_Left_left_Regular :
		{
			/* Default exit sequence for state Regular */
			handle->stateConfVector[0] = Signalcontrol_last_state;
			/* Exit action for state 'Left'. */
			blink_exit(handle->iface.blinkLeft);
			break;
		}
		case Signalcontrol_main_Hazard_Lights :
		{
			/* Default exit sequence for state Hazard Lights */
			handle->stateConfVector[0] = Signalcontrol_last_state;
			/* Exit action for state 'Hazard Lights'. */
			flash_exit(handle->iface.flash);
			break;
		}
		default: 
			/* do nothing */
			break;
	}
	handle->isExecuting = bool_false;
}

/*!
Can be used by the client code to trigger a run to completion step without raising an event.
*/
void signalcontrol_trigger_without_event(Signalcontrol* handle) {
	run_cycle(handle);
}


sc_boolean signalcontrol_is_active(const Signalcontrol* handle)
{
	sc_boolean result = bool_false;
	sc_integer i;
	
	for(i = 0; i < SIGNALCONTROL_MAX_ORTHOGONAL_STATES; i++)
	{
		result = result || handle->stateConfVector[i] != Signalcontrol_last_state;
	}
	
	return result;
}

/* 
 * Always returns 'false' since this state machine can never become final.
 */
sc_boolean signalcontrol_is_final(const Signalcontrol* handle)
{
	SC_UNUSED(handle);
	return bool_false;
}

sc_boolean signalcontrol_is_state_active(const Signalcontrol* handle, SignalcontrolStates state)
{
	sc_boolean result = bool_false;
	switch (state)
	{
		case Signalcontrol_main_Idle :
			result = (sc_boolean) (handle->stateConfVector[SCVI_SIGNALCONTROL_MAIN_IDLE] == Signalcontrol_main_Idle
			);
				break;
		case Signalcontrol_main_Blink :
			result = (sc_boolean) (handle->stateConfVector[SCVI_SIGNALCONTROL_MAIN_BLINK] >= Signalcontrol_main_Blink
				&& handle->stateConfVector[SCVI_SIGNALCONTROL_MAIN_BLINK] <= Signalcontrol_main_Blink_r_Left_left_Regular);
				break;
		case Signalcontrol_main_Blink_r_Right :
			result = (sc_boolean) (handle->stateConfVector[SCVI_SIGNALCONTROL_MAIN_BLINK_R_RIGHT] >= Signalcontrol_main_Blink_r_Right
				&& handle->stateConfVector[SCVI_SIGNALCONTROL_MAIN_BLINK_R_RIGHT] <= Signalcontrol_main_Blink_r_Right_right_Regular);
				break;
		case Signalcontrol_main_Blink_r_Right_right_Comfort :
			result = (sc_boolean) (handle->stateConfVector[SCVI_SIGNALCONTROL_MAIN_BLINK_R_RIGHT_RIGHT_COMFORT] == Signalcontrol_main_Blink_r_Right_right_Comfort
			);
				break;
		case Signalcontrol_main_Blink_r_Right_right_Regular :
			result = (sc_boolean) (handle->stateConfVector[SCVI_SIGNALCONTROL_MAIN_BLINK_R_RIGHT_RIGHT_REGULAR] == Signalcontrol_main_Blink_r_Right_right_Regular
			);
				break;
		case Signalcontrol_main_Blink_r_Left :
			result = (sc_boolean) (handle->stateConfVector[SCVI_SIGNALCONTROL_MAIN_BLINK_R_LEFT] >= Signalcontrol_main_Blink_r_Left
				&& handle->stateConfVector[SCVI_SIGNALCONTROL_MAIN_BLINK_R_LEFT] <= Signalcontrol_main_Blink_r_Left_left_Regular);
				break;
		case Signalcontrol_main_Blink_r_Left_left_Comfort :
			result = (sc_boolean) (handle->stateConfVector[SCVI_SIGNALCONTROL_MAIN_BLINK_R_LEFT_LEFT_COMFORT] == Signalcontrol_main_Blink_r_Left_left_Comfort
			);
				break;
		case Signalcontrol_main_Blink_r_Left_left_Regular :
			result = (sc_boolean) (handle->stateConfVector[SCVI_SIGNALCONTROL_MAIN_BLINK_R_LEFT_LEFT_REGULAR] == Signalcontrol_main_Blink_r_Left_left_Regular
			);
				break;
		case Signalcontrol_main_Hazard_Lights :
			result = (sc_boolean) (handle->stateConfVector[SCVI_SIGNALCONTROL_MAIN_HAZARD_LIGHTS] == Signalcontrol_main_Hazard_Lights
			);
				break;
			default:
				result = bool_false;
				break;
		}
		return result;
	}

static void clear_in_events(Signalcontrol* handle)
{
	handle->iface.right_raised = bool_false;
	handle->iface.left_raised = bool_false;
	handle->iface.hazard_raised = bool_false;
	handle->shadow.blinkRight_cycleCompleted_raised = bool_false;
	handle->shadow.blinkLeft_cycleCompleted_raised = bool_false;
}

static void clear_internal_events(Signalcontrol* handle)
{
	handle->internal.stopBlinking_raised = bool_false;
}

static void micro_step(Signalcontrol* handle)
{
	switch(handle->stateConfVector[ 0 ])
	{
		case Signalcontrol_main_Idle :
		{
			main_Idle_react(handle,-1);
			break;
		}
		case Signalcontrol_main_Blink_r_Right_right_Comfort :
		{
			main_Blink_r_Right_right_Comfort_react(handle,-1);
			break;
		}
		case Signalcontrol_main_Blink_r_Right_right_Regular :
		{
			main_Blink_r_Right_right_Regular_react(handle,-1);
			break;
		}
		case Signalcontrol_main_Blink_r_Left_left_Comfort :
		{
			main_Blink_r_Left_left_Comfort_react(handle,-1);
			break;
		}
		case Signalcontrol_main_Blink_r_Left_left_Regular :
		{
			main_Blink_r_Left_left_Regular_react(handle,-1);
			break;
		}
		case Signalcontrol_main_Hazard_Lights :
		{
			main_Hazard_Lights_react(handle,-1);
			break;
		}
		default: 
			/* do nothing */
			break;
	}
}

static void run_cycle(Signalcontrol* handle)
{
	/* Performs a 'run to completion' step. */
	if (handle->isExecuting == bool_true)
	{ 
		return;
	} 
	handle->isExecuting = bool_true;
	signalcontrol_dispatch_next_event(handle);
	do
	{ 
		micro_step(handle);
		clear_in_events(handle);
		clear_internal_events(handle);
	} while (signalcontrol_dispatch_next_event(handle) == bool_true);
	handle->isExecuting = bool_false;
}


void signalcontrol_raise_right(Signalcontrol* handle, sc_boolean value)
{
	signalcontrol_add_value_event_to_queue(&(handle->in_event_queue), Signalcontrol_right, &value);
	run_cycle(handle);
}

void signalcontrol_raise_left(Signalcontrol* handle, sc_boolean value)
{
	signalcontrol_add_value_event_to_queue(&(handle->in_event_queue), Signalcontrol_left, &value);
	run_cycle(handle);
}

void signalcontrol_raise_hazard(Signalcontrol* handle)
{
	signalcontrol_add_event_to_queue(&(handle->in_event_queue), Signalcontrol_hazard);
	run_cycle(handle);
}



Blink* signalcontrol_get_blinkRight(const Signalcontrol* handle)
{
	return handle->iface.blinkRight;
}
void signalcontrol_set_blinkRight(Signalcontrol* handle, Blink* value)
{
	if(handle->iface.blinkRight != sc_null)
	{
		sc_single_subscription_observer_unsubscribe(&(handle->shadow.blinkRight_cycleCompleted), blink_get_cycleCompleted(handle->iface.blinkRight));
	}
	handle->iface.blinkRight = value;
	if(handle->iface.blinkRight != sc_null)
	{
		sc_single_subscription_observer_subscribe(&(handle->shadow.blinkRight_cycleCompleted), blink_get_cycleCompleted(handle->iface.blinkRight));
	}
}
Blink* signalcontrol_get_blinkLeft(const Signalcontrol* handle)
{
	return handle->iface.blinkLeft;
}
void signalcontrol_set_blinkLeft(Signalcontrol* handle, Blink* value)
{
	if(handle->iface.blinkLeft != sc_null)
	{
		sc_single_subscription_observer_unsubscribe(&(handle->shadow.blinkLeft_cycleCompleted), blink_get_cycleCompleted(handle->iface.blinkLeft));
	}
	handle->iface.blinkLeft = value;
	if(handle->iface.blinkLeft != sc_null)
	{
		sc_single_subscription_observer_subscribe(&(handle->shadow.blinkLeft_cycleCompleted), blink_get_cycleCompleted(handle->iface.blinkLeft));
	}
}
Flash* signalcontrol_get_flash(const Signalcontrol* handle)
{
	return handle->iface.flash;
}
void signalcontrol_set_flash(Signalcontrol* handle, Flash* value)
{
	handle->iface.flash = value;
}
sc_integer signalcontrol_get_comfortBlinkingPeriods(const Signalcontrol* handle)
{
	return handle->iface.comfortBlinkingPeriods;
}
void signalcontrol_set_comfortBlinkingPeriods(Signalcontrol* handle, sc_integer value)
{
	handle->iface.comfortBlinkingPeriods = value;
}

static void signalcontrol_internal_set_interrupted(Signalcontrol* handle, sc_boolean value)
{
	handle->internal.interrupted = value;
}
static void signalcontrol_internal_set_periodCount(Signalcontrol* handle, sc_integer value)
{
	handle->internal.periodCount = value;
}


/* implementations of all internal functions */

/* deep enterSequence with history in child r */
static void dhenseq_main_Blink_r(Signalcontrol* handle)
{
	/* deep enterSequence with history in child r */
	/* Handle deep history entry of r */
	switch(handle->historyVector[ 0 ])
	{
		case Signalcontrol_main_Blink_r_Right_right_Comfort :
		{
			/* enterSequence with history in child Right for leaf Comfort */
			/* Entry action for state 'Right'. */
			blink_enter(handle->iface.blinkRight);
			dhenseq_main_Blink_r_Right_right(handle);
			break;
		}
		case Signalcontrol_main_Blink_r_Right_right_Regular :
		{
			/* enterSequence with history in child Right for leaf Regular */
			/* Entry action for state 'Right'. */
			blink_enter(handle->iface.blinkRight);
			dhenseq_main_Blink_r_Right_right(handle);
			break;
		}
		case Signalcontrol_main_Blink_r_Left_left_Comfort :
		{
			/* enterSequence with history in child Left for leaf Comfort */
			/* Entry action for state 'Left'. */
			blink_enter(handle->iface.blinkLeft);
			dhenseq_main_Blink_r_Left_left(handle);
			break;
		}
		case Signalcontrol_main_Blink_r_Left_left_Regular :
		{
			/* enterSequence with history in child Left for leaf Regular */
			/* Entry action for state 'Left'. */
			blink_enter(handle->iface.blinkLeft);
			dhenseq_main_Blink_r_Left_left(handle);
			break;
		}
		default: 
			/* do nothing */
			break;
	}
}

/* deep enterSequence with history in child right */
static void dhenseq_main_Blink_r_Right_right(Signalcontrol* handle)
{
	/* deep enterSequence with history in child right */
	/* Handle deep history entry of right */
	switch(handle->historyVector[ 1 ])
	{
		case Signalcontrol_main_Blink_r_Right_right_Comfort :
		{
			/* enterSequence with history in child Comfort for leaf Comfort */
			/* 'default' enter sequence for state Comfort */
			/* Entry action for state 'Comfort'. */
			signalcontrol_internal_set_periodCount(handle, handle->iface.comfortBlinkingPeriods);
			handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Right_right_Comfort;
			handle->historyVector[1] = handle->stateConfVector[0];
			break;
		}
		case Signalcontrol_main_Blink_r_Right_right_Regular :
		{
			/* enterSequence with history in child Regular for leaf Regular */
			/* 'default' enter sequence for state Regular */
			/* Entry action for state 'Regular'. */
			signalcontrol_internal_set_periodCount(handle, -(1));
			handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Right_right_Regular;
			handle->historyVector[1] = handle->stateConfVector[0];
			break;
		}
		default: 
			/* do nothing */
			break;
	}
}

/* deep enterSequence with history in child left */
static void dhenseq_main_Blink_r_Left_left(Signalcontrol* handle)
{
	/* deep enterSequence with history in child left */
	/* Handle deep history entry of left */
	switch(handle->historyVector[ 2 ])
	{
		case Signalcontrol_main_Blink_r_Left_left_Comfort :
		{
			/* enterSequence with history in child Comfort for leaf Comfort */
			/* 'default' enter sequence for state Comfort */
			/* Entry action for state 'Comfort'. */
			signalcontrol_internal_set_periodCount(handle, handle->iface.comfortBlinkingPeriods);
			handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Left_left_Comfort;
			handle->historyVector[2] = handle->stateConfVector[0];
			break;
		}
		case Signalcontrol_main_Blink_r_Left_left_Regular :
		{
			/* enterSequence with history in child Regular for leaf Regular */
			/* 'default' enter sequence for state Regular */
			/* Entry action for state 'Regular'. */
			signalcontrol_internal_set_periodCount(handle, -(1));
			handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Left_left_Regular;
			handle->historyVector[2] = handle->stateConfVector[0];
			break;
		}
		default: 
			/* do nothing */
			break;
	}
}

/* The reactions of state null. */
static void react_main_Blink_r_Right_right__choice_0(Signalcontrol* handle)
{
	/* The reactions of state null. */
	if (handle->iface.right_value == bool_true)
	{ 
		/* 'default' enter sequence for state Comfort */
		/* Entry action for state 'Comfort'. */
		signalcontrol_internal_set_periodCount(handle, handle->iface.comfortBlinkingPeriods);
		handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Right_right_Comfort;
		handle->historyVector[1] = handle->stateConfVector[0];
	}  else
	{
		/* 'default' enter sequence for state Regular */
		/* Entry action for state 'Regular'. */
		signalcontrol_internal_set_periodCount(handle, -(1));
		handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Right_right_Regular;
		handle->historyVector[1] = handle->stateConfVector[0];
	}
}


static sc_integer react(Signalcontrol* handle, const sc_integer transitioned_before)
{
	/* State machine reactions. */
	if ((((handle->shadow.blinkRight_cycleCompleted_raised == bool_true) || (handle->shadow.blinkLeft_cycleCompleted_raised == bool_true)) == bool_true) && (((handle->internal.periodCount) > (0)) == bool_true))
	{ 
		signalcontrol_internal_set_periodCount(handle, handle->internal.periodCount - 1);
	} 
	if ((handle->internal.periodCount) == (0))
	{ 
		signalcontrol_add_event_to_queue(&(handle->internal_event_queue), Signalcontrol_internal_stopBlinking);
	} 
	return transitioned_before;
}

static sc_integer main_Idle_react(Signalcontrol* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Idle. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->iface.right_raised == bool_true)
		{ 
			/* Default exit sequence for state Idle */
			handle->stateConfVector[0] = Signalcontrol_last_state;
			/* 'default' enter sequence for state Right */
			/* Entry action for state 'Right'. */
			blink_enter(handle->iface.blinkRight);
			/* 'default' enter sequence for region right */
			/* Default react sequence for initial entry  */
			/* The reactions of state null. */
			if (handle->iface.right_value == bool_true)
			{ 
				/* 'default' enter sequence for state Comfort */
				/* Entry action for state 'Comfort'. */
				signalcontrol_internal_set_periodCount(handle, handle->iface.comfortBlinkingPeriods);
				handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Right_right_Comfort;
				handle->historyVector[1] = handle->stateConfVector[0];
			}  else
			{
				/* 'default' enter sequence for state Regular */
				/* Entry action for state 'Regular'. */
				signalcontrol_internal_set_periodCount(handle, -(1));
				handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Right_right_Regular;
				handle->historyVector[1] = handle->stateConfVector[0];
			}
			handle->historyVector[0] = handle->stateConfVector[0];
			react(handle,0);
			transitioned_after = 0;
		}  else
		{
			if (handle->iface.left_raised == bool_true)
			{ 
				/* Default exit sequence for state Idle */
				handle->stateConfVector[0] = Signalcontrol_last_state;
				/* 'default' enter sequence for state Left */
				/* Entry action for state 'Left'. */
				blink_enter(handle->iface.blinkLeft);
				/* 'default' enter sequence for region left */
				/* Default react sequence for initial entry  */
				/* The reactions of state null. */
				if (handle->iface.left_value == bool_true)
				{ 
					/* 'default' enter sequence for state Comfort */
					/* Entry action for state 'Comfort'. */
					signalcontrol_internal_set_periodCount(handle, handle->iface.comfortBlinkingPeriods);
					handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Left_left_Comfort;
					handle->historyVector[2] = handle->stateConfVector[0];
				}  else
				{
					/* 'default' enter sequence for state Regular */
					/* Entry action for state 'Regular'. */
					signalcontrol_internal_set_periodCount(handle, -(1));
					handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Left_left_Regular;
					handle->historyVector[2] = handle->stateConfVector[0];
				}
				handle->historyVector[0] = handle->stateConfVector[0];
				react(handle,0);
				transitioned_after = 0;
			}  else
			{
				if (handle->iface.hazard_raised == bool_true)
				{ 
					/* Default exit sequence for state Idle */
					handle->stateConfVector[0] = Signalcontrol_last_state;
					/* 'default' enter sequence for state Hazard Lights */
					/* Entry action for state 'Hazard Lights'. */
					flash_enter(handle->iface.flash);
					handle->stateConfVector[0] = Signalcontrol_main_Hazard_Lights;
					react(handle,0);
					transitioned_after = 0;
				} 
			}
		}
	} 
	/* If no transition was taken */
	if ((transitioned_after) == (transitioned_before))
	{ 
		/* then execute local reactions. */
		transitioned_after = react(handle,transitioned_before);
	} 
	return transitioned_after;
}

static sc_integer main_Blink_react(Signalcontrol* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Blink. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->internal.stopBlinking_raised == bool_true)
		{ 
			/* Default exit sequence for state Blink */
			/* Default exit sequence for region r */
			/* Handle exit of all possible states (of signalcontrol.main.Blink.r) at position 0... */
			switch(handle->stateConfVector[ 0 ])
			{
				case Signalcontrol_main_Blink_r_Right_right_Comfort :
				{
					/* Default exit sequence for state Comfort */
					handle->stateConfVector[0] = Signalcontrol_last_state;
					/* Exit action for state 'Right'. */
					blink_exit(handle->iface.blinkRight);
					break;
				}
				case Signalcontrol_main_Blink_r_Right_right_Regular :
				{
					/* Default exit sequence for state Regular */
					handle->stateConfVector[0] = Signalcontrol_last_state;
					/* Exit action for state 'Right'. */
					blink_exit(handle->iface.blinkRight);
					break;
				}
				case Signalcontrol_main_Blink_r_Left_left_Comfort :
				{
					/* Default exit sequence for state Comfort */
					handle->stateConfVector[0] = Signalcontrol_last_state;
					/* Exit action for state 'Left'. */
					blink_exit(handle->iface.blinkLeft);
					break;
				}
				case Signalcontrol_main_Blink_r_Left_left_Regular :
				{
					/* Default exit sequence for state Regular */
					handle->stateConfVector[0] = Signalcontrol_last_state;
					/* Exit action for state 'Left'. */
					blink_exit(handle->iface.blinkLeft);
					break;
				}
				default: 
					/* do nothing */
					break;
			}
			/* The reactions of state null. */
			if (handle->internal.interrupted == bool_true)
			{ 
				signalcontrol_internal_set_interrupted(handle, bool_false);
				/* 'default' enter sequence for state Hazard Lights */
				/* Entry action for state 'Hazard Lights'. */
				flash_enter(handle->iface.flash);
				handle->stateConfVector[0] = Signalcontrol_main_Hazard_Lights;
			}  else
			{
				/* 'default' enter sequence for state Idle */
				handle->stateConfVector[0] = Signalcontrol_main_Idle;
			}
			transitioned_after = 0;
		}  else
		{
			if (((handle->iface.hazard_raised) == bool_true) && ((!(handle->internal.interrupted)) == bool_true))
			{ 
				/* Default exit sequence for state Blink */
				/* Default exit sequence for region r */
				/* Handle exit of all possible states (of signalcontrol.main.Blink.r) at position 0... */
				switch(handle->stateConfVector[ 0 ])
				{
					case Signalcontrol_main_Blink_r_Right_right_Comfort :
					{
						/* Default exit sequence for state Comfort */
						handle->stateConfVector[0] = Signalcontrol_last_state;
						/* Exit action for state 'Right'. */
						blink_exit(handle->iface.blinkRight);
						break;
					}
					case Signalcontrol_main_Blink_r_Right_right_Regular :
					{
						/* Default exit sequence for state Regular */
						handle->stateConfVector[0] = Signalcontrol_last_state;
						/* Exit action for state 'Right'. */
						blink_exit(handle->iface.blinkRight);
						break;
					}
					case Signalcontrol_main_Blink_r_Left_left_Comfort :
					{
						/* Default exit sequence for state Comfort */
						handle->stateConfVector[0] = Signalcontrol_last_state;
						/* Exit action for state 'Left'. */
						blink_exit(handle->iface.blinkLeft);
						break;
					}
					case Signalcontrol_main_Blink_r_Left_left_Regular :
					{
						/* Default exit sequence for state Regular */
						handle->stateConfVector[0] = Signalcontrol_last_state;
						/* Exit action for state 'Left'. */
						blink_exit(handle->iface.blinkLeft);
						break;
					}
					default: 
						/* do nothing */
						break;
				}
				signalcontrol_internal_set_interrupted(handle, bool_true);
				/* 'default' enter sequence for state Hazard Lights */
				/* Entry action for state 'Hazard Lights'. */
				flash_enter(handle->iface.flash);
				handle->stateConfVector[0] = Signalcontrol_main_Hazard_Lights;
				react(handle,0);
				transitioned_after = 0;
			} 
		}
	} 
	/* If no transition was taken */
	if ((transitioned_after) == (transitioned_before))
	{ 
		/* then execute local reactions. */
		transitioned_after = react(handle,transitioned_before);
	} 
	return transitioned_after;
}

static sc_integer main_Blink_r_Right_react(Signalcontrol* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Right. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->iface.left_raised == bool_true)
		{ 
			/* Default exit sequence for state Right */
			/* Default exit sequence for region right */
			/* Handle exit of all possible states (of signalcontrol.main.Blink.r.Right.right) at position 0... */
			switch(handle->stateConfVector[ 0 ])
			{
				case Signalcontrol_main_Blink_r_Right_right_Comfort :
				{
					/* Default exit sequence for state Comfort */
					handle->stateConfVector[0] = Signalcontrol_last_state;
					break;
				}
				case Signalcontrol_main_Blink_r_Right_right_Regular :
				{
					/* Default exit sequence for state Regular */
					handle->stateConfVector[0] = Signalcontrol_last_state;
					break;
				}
				default: 
					/* do nothing */
					break;
			}
			/* Exit action for state 'Right'. */
			blink_exit(handle->iface.blinkRight);
			/* 'default' enter sequence for state Left */
			/* Entry action for state 'Left'. */
			blink_enter(handle->iface.blinkLeft);
			/* 'default' enter sequence for region left */
			/* Default react sequence for initial entry  */
			/* The reactions of state null. */
			if (handle->iface.left_value == bool_true)
			{ 
				/* 'default' enter sequence for state Comfort */
				/* Entry action for state 'Comfort'. */
				signalcontrol_internal_set_periodCount(handle, handle->iface.comfortBlinkingPeriods);
				handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Left_left_Comfort;
				handle->historyVector[2] = handle->stateConfVector[0];
			}  else
			{
				/* 'default' enter sequence for state Regular */
				/* Entry action for state 'Regular'. */
				signalcontrol_internal_set_periodCount(handle, -(1));
				handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Left_left_Regular;
				handle->historyVector[2] = handle->stateConfVector[0];
			}
			handle->historyVector[0] = handle->stateConfVector[0];
			main_Blink_react(handle,0);
			transitioned_after = 0;
		} 
	} 
	/* If no transition was taken */
	if ((transitioned_after) == (transitioned_before))
	{ 
		/* then execute local reactions. */
		transitioned_after = main_Blink_react(handle,transitioned_before);
	} 
	return transitioned_after;
}

static sc_integer main_Blink_r_Right_right_Comfort_react(Signalcontrol* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Comfort. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->iface.right_raised == bool_true)
		{ 
			/* Default exit sequence for state Comfort */
			handle->stateConfVector[0] = Signalcontrol_last_state;
			/* The reactions of state null. */
			if (handle->iface.right_value == bool_true)
			{ 
				/* 'default' enter sequence for state Comfort */
				/* Entry action for state 'Comfort'. */
				signalcontrol_internal_set_periodCount(handle, handle->iface.comfortBlinkingPeriods);
				handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Right_right_Comfort;
				handle->historyVector[1] = handle->stateConfVector[0];
			}  else
			{
				/* 'default' enter sequence for state Regular */
				/* Entry action for state 'Regular'. */
				signalcontrol_internal_set_periodCount(handle, -(1));
				handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Right_right_Regular;
				handle->historyVector[1] = handle->stateConfVector[0];
			}
			transitioned_after = 0;
		} 
	} 
	/* If no transition was taken */
	if ((transitioned_after) == (transitioned_before))
	{ 
		/* then execute local reactions. */
		transitioned_after = main_Blink_r_Right_react(handle,transitioned_before);
	} 
	return transitioned_after;
}

static sc_integer main_Blink_r_Right_right_Regular_react(Signalcontrol* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Regular. */
 			sc_integer transitioned_after = transitioned_before;
	/* If no transition was taken */
	if ((transitioned_after) == (transitioned_before))
	{ 
		/* then execute local reactions. */
		if (handle->iface.right_raised == bool_true)
		{ 
			signalcontrol_internal_set_periodCount(handle, 1);
		} 
		transitioned_after = main_Blink_r_Right_react(handle,transitioned_before);
	} 
	return transitioned_after;
}

static sc_integer main_Blink_r_Left_react(Signalcontrol* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Left. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->iface.right_raised == bool_true)
		{ 
			/* Default exit sequence for state Left */
			/* Default exit sequence for region left */
			/* Handle exit of all possible states (of signalcontrol.main.Blink.r.Left.left) at position 0... */
			switch(handle->stateConfVector[ 0 ])
			{
				case Signalcontrol_main_Blink_r_Left_left_Comfort :
				{
					/* Default exit sequence for state Comfort */
					handle->stateConfVector[0] = Signalcontrol_last_state;
					break;
				}
				case Signalcontrol_main_Blink_r_Left_left_Regular :
				{
					/* Default exit sequence for state Regular */
					handle->stateConfVector[0] = Signalcontrol_last_state;
					break;
				}
				default: 
					/* do nothing */
					break;
			}
			/* Exit action for state 'Left'. */
			blink_exit(handle->iface.blinkLeft);
			/* 'default' enter sequence for state Right */
			/* Entry action for state 'Right'. */
			blink_enter(handle->iface.blinkRight);
			/* 'default' enter sequence for region right */
			/* Default react sequence for initial entry  */
			/* The reactions of state null. */
			if (handle->iface.right_value == bool_true)
			{ 
				/* 'default' enter sequence for state Comfort */
				/* Entry action for state 'Comfort'. */
				signalcontrol_internal_set_periodCount(handle, handle->iface.comfortBlinkingPeriods);
				handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Right_right_Comfort;
				handle->historyVector[1] = handle->stateConfVector[0];
			}  else
			{
				/* 'default' enter sequence for state Regular */
				/* Entry action for state 'Regular'. */
				signalcontrol_internal_set_periodCount(handle, -(1));
				handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Right_right_Regular;
				handle->historyVector[1] = handle->stateConfVector[0];
			}
			handle->historyVector[0] = handle->stateConfVector[0];
			main_Blink_react(handle,0);
			transitioned_after = 0;
		} 
	} 
	/* If no transition was taken */
	if ((transitioned_after) == (transitioned_before))
	{ 
		/* then execute local reactions. */
		transitioned_after = main_Blink_react(handle,transitioned_before);
	} 
	return transitioned_after;
}

static sc_integer main_Blink_r_Left_left_Comfort_react(Signalcontrol* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Comfort. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->iface.left_raised == bool_true)
		{ 
			/* Default exit sequence for state Comfort */
			handle->stateConfVector[0] = Signalcontrol_last_state;
			/* The reactions of state null. */
			if (handle->iface.left_value == bool_true)
			{ 
				/* 'default' enter sequence for state Comfort */
				/* Entry action for state 'Comfort'. */
				signalcontrol_internal_set_periodCount(handle, handle->iface.comfortBlinkingPeriods);
				handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Left_left_Comfort;
				handle->historyVector[2] = handle->stateConfVector[0];
			}  else
			{
				/* 'default' enter sequence for state Regular */
				/* Entry action for state 'Regular'. */
				signalcontrol_internal_set_periodCount(handle, -(1));
				handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Left_left_Regular;
				handle->historyVector[2] = handle->stateConfVector[0];
			}
			transitioned_after = 0;
		} 
	} 
	/* If no transition was taken */
	if ((transitioned_after) == (transitioned_before))
	{ 
		/* then execute local reactions. */
		transitioned_after = main_Blink_r_Left_react(handle,transitioned_before);
	} 
	return transitioned_after;
}

static sc_integer main_Blink_r_Left_left_Regular_react(Signalcontrol* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Regular. */
 			sc_integer transitioned_after = transitioned_before;
	/* If no transition was taken */
	if ((transitioned_after) == (transitioned_before))
	{ 
		/* then execute local reactions. */
		if (handle->iface.left_raised == bool_true)
		{ 
			signalcontrol_internal_set_periodCount(handle, 1);
		} 
		transitioned_after = main_Blink_r_Left_react(handle,transitioned_before);
	} 
	return transitioned_after;
}

static sc_integer main_Hazard_Lights_react(Signalcontrol* handle, const sc_integer transitioned_before)
{
	/* The reactions of state Hazard Lights. */
 			sc_integer transitioned_after = transitioned_before;
	if ((transitioned_after) < (0))
	{ 
		if (handle->iface.hazard_raised == bool_true)
		{ 
			/* Default exit sequence for state Hazard Lights */
			handle->stateConfVector[0] = Signalcontrol_last_state;
			/* Exit action for state 'Hazard Lights'. */
			flash_exit(handle->iface.flash);
			/* The reactions of state null. */
			if (handle->internal.interrupted == bool_true)
			{ 
				signalcontrol_internal_set_interrupted(handle, bool_false);
				/* Default react sequence for deep history entry  */
				/* Enter the region with deep history */
				if (handle->historyVector[0] != Signalcontrol_last_state)
				{
					dhenseq_main_Blink_r(handle);
				} else
				{
					/* 'default' enter sequence for state Right */
					/* Entry action for state 'Right'. */
					blink_enter(handle->iface.blinkRight);
					/* 'default' enter sequence for region right */
					/* Default react sequence for initial entry  */
					react_main_Blink_r_Right_right__choice_0(handle);
					handle->historyVector[0] = handle->stateConfVector[0];
				} 
			}  else
			{
				/* 'default' enter sequence for state Idle */
				handle->stateConfVector[0] = Signalcontrol_main_Idle;
			}
			transitioned_after = 0;
		}  else
		{
			if (((handle->iface.right_raised) == bool_true) && ((!(handle->internal.interrupted)) == bool_true))
			{ 
				/* Default exit sequence for state Hazard Lights */
				handle->stateConfVector[0] = Signalcontrol_last_state;
				/* Exit action for state 'Hazard Lights'. */
				flash_exit(handle->iface.flash);
				signalcontrol_internal_set_interrupted(handle, bool_true);
				/* 'default' enter sequence for state Right */
				/* Entry action for state 'Right'. */
				blink_enter(handle->iface.blinkRight);
				/* 'default' enter sequence for region right */
				/* Default react sequence for initial entry  */
				/* The reactions of state null. */
				if (handle->iface.right_value == bool_true)
				{ 
					/* 'default' enter sequence for state Comfort */
					/* Entry action for state 'Comfort'. */
					signalcontrol_internal_set_periodCount(handle, handle->iface.comfortBlinkingPeriods);
					handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Right_right_Comfort;
					handle->historyVector[1] = handle->stateConfVector[0];
				}  else
				{
					/* 'default' enter sequence for state Regular */
					/* Entry action for state 'Regular'. */
					signalcontrol_internal_set_periodCount(handle, -(1));
					handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Right_right_Regular;
					handle->historyVector[1] = handle->stateConfVector[0];
				}
				handle->historyVector[0] = handle->stateConfVector[0];
				react(handle,0);
				transitioned_after = 0;
			}  else
			{
				if (((handle->iface.left_raised) == bool_true) && ((!(handle->internal.interrupted)) == bool_true))
				{ 
					/* Default exit sequence for state Hazard Lights */
					handle->stateConfVector[0] = Signalcontrol_last_state;
					/* Exit action for state 'Hazard Lights'. */
					flash_exit(handle->iface.flash);
					signalcontrol_internal_set_interrupted(handle, bool_true);
					/* 'default' enter sequence for state Left */
					/* Entry action for state 'Left'. */
					blink_enter(handle->iface.blinkLeft);
					/* 'default' enter sequence for region left */
					/* Default react sequence for initial entry  */
					/* The reactions of state null. */
					if (handle->iface.left_value == bool_true)
					{ 
						/* 'default' enter sequence for state Comfort */
						/* Entry action for state 'Comfort'. */
						signalcontrol_internal_set_periodCount(handle, handle->iface.comfortBlinkingPeriods);
						handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Left_left_Comfort;
						handle->historyVector[2] = handle->stateConfVector[0];
					}  else
					{
						/* 'default' enter sequence for state Regular */
						/* Entry action for state 'Regular'. */
						signalcontrol_internal_set_periodCount(handle, -(1));
						handle->stateConfVector[0] = Signalcontrol_main_Blink_r_Left_left_Regular;
						handle->historyVector[2] = handle->stateConfVector[0];
					}
					handle->historyVector[0] = handle->stateConfVector[0];
					react(handle,0);
					transitioned_after = 0;
				} 
			}
		}
	} 
	/* If no transition was taken */
	if ((transitioned_after) == (transitioned_before))
	{ 
		/* then execute local reactions. */
		transitioned_after = react(handle,transitioned_before);
	} 
	return transitioned_after;
}


static void on_blinkRight_cycleCompleted(Signalcontrol* handle)
{
	signalcontrol_add_event_to_queue(&(handle->in_event_queue), Signalcontrol_internal_blinkRight_cycleCompleted);
	run_cycle(handle);
}
static void on_blinkLeft_cycleCompleted(Signalcontrol* handle)
{
	signalcontrol_add_event_to_queue(&(handle->in_event_queue), Signalcontrol_internal_blinkLeft_cycleCompleted);
	run_cycle(handle);
}


static void signalcontrol_eventqueue_init(signalcontrol_eventqueue * eq, signalcontrol_event *buffer, sc_integer capacity)
{
	eq->events = buffer;
	eq->capacity = capacity;
	eq->push_index = 0;
	eq->pop_index = 0;
	eq->size = 0;
}

static sc_integer signalcontrol_eventqueue_size(signalcontrol_eventqueue * eq)
{
	return eq->size;
}

static signalcontrol_event signalcontrol_eventqueue_pop(signalcontrol_eventqueue * eq)
{
	signalcontrol_event event;
	if(signalcontrol_eventqueue_size(eq) <= 0) {
		signalcontrol_event_init(&event, Signalcontrol_invalid_event);
	}
	else {
		event = eq->events[eq->pop_index];
		
		if(eq->pop_index < eq->capacity - 1) {
			eq->pop_index++;
		} 
		else {
			eq->pop_index = 0;
		}
		eq->size--;
	}
	return event;
}
static sc_boolean signalcontrol_eventqueue_push(signalcontrol_eventqueue * eq, signalcontrol_event ev)
{
	if(signalcontrol_eventqueue_size(eq) == eq->capacity) {
		return bool_false;
	}
	else {
		eq->events[eq->push_index] = ev;
		
		if(eq->push_index < eq->capacity - 1) {
			eq->push_index++;
		}
		else {
			eq->push_index = 0;
		}
		eq->size++;
		
		return bool_true;
	}
}
static void signalcontrol_event_init(signalcontrol_event * ev, SignalcontrolEventID name)
{
	ev->name = name;
	ev->has_value = bool_false;
}

static void signalcontrol_add_event_to_queue(signalcontrol_eventqueue * eq, SignalcontrolEventID name)
{
	signalcontrol_event event;
	signalcontrol_event_init(&event, name);
	signalcontrol_eventqueue_push(eq, event);
}

static sc_boolean signalcontrol_dispatch_event(Signalcontrol* handle, const signalcontrol_event * event) {
	switch(event->name) {
		case Signalcontrol_right:
		{
			handle->iface.right_raised = bool_true;
			handle->iface.right_value = event->value.Signalcontrol_right_value;
			return bool_true;
		}
		case Signalcontrol_left:
		{
			handle->iface.left_raised = bool_true;
			handle->iface.left_value = event->value.Signalcontrol_left_value;
			return bool_true;
		}
		case Signalcontrol_hazard:
		{
			handle->iface.hazard_raised = bool_true;
			return bool_true;
		}
		case Signalcontrol_internal_stopBlinking:
		{
			handle->internal.stopBlinking_raised = bool_true;
			return bool_true;
		}
		case Signalcontrol_internal_blinkRight_cycleCompleted:
		{
			handle->shadow.blinkRight_cycleCompleted_raised = bool_true;
			return bool_true;
		}
		case Signalcontrol_internal_blinkLeft_cycleCompleted:
		{
			handle->shadow.blinkLeft_cycleCompleted_raised = bool_true;
			return bool_true;
		}
		default:
			return bool_false;
	}
}

static signalcontrol_event signalcontrol_get_next_event(Signalcontrol* handle)
{
	signalcontrol_event next_event;
	signalcontrol_event_init(&next_event, Signalcontrol_invalid_event);
	if(signalcontrol_eventqueue_size(&(handle->internal_event_queue)) > 0) {
		next_event = signalcontrol_eventqueue_pop(&(handle->internal_event_queue));
	}
	else if(signalcontrol_eventqueue_size(&(handle->in_event_queue)) > 0) {
		next_event = signalcontrol_eventqueue_pop(&(handle->in_event_queue));
	}
	return next_event;
}

static sc_boolean signalcontrol_dispatch_next_event(Signalcontrol* handle)
{
	signalcontrol_event nextEvent;
	nextEvent = signalcontrol_get_next_event(handle);
	return signalcontrol_dispatch_event(handle, &nextEvent);
}

static void signalcontrol_event_value_init(signalcontrol_event * ev, SignalcontrolEventID name, void * value)
{
	ev->name = name;
	ev->has_value = bool_true;
	
	switch(name)
	{
		case Signalcontrol_right:
			ev->value.Signalcontrol_right_value = *((sc_boolean*)value);
			break;
		case Signalcontrol_left:
			ev->value.Signalcontrol_left_value = *((sc_boolean*)value);
			break;
		default:
			/* do nothing */
			break;
	}
}

static void signalcontrol_add_value_event_to_queue(signalcontrol_eventqueue * eq, SignalcontrolEventID name, void * value)
{
	signalcontrol_event event;
	signalcontrol_event_value_init(&event, name, value);
	signalcontrol_eventqueue_push(eq, event);
}
